/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include <stdint.h>
#include "stm32f4xx.h"
#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "ExtiDriver.h"


/* Definición de los elementos */
GPIO_Handler_t 	handlerLED2 				= {0};
GPIO_Handler_t 	handlerButton 				= {0};
GPIO_Handler_t 	handlerCLK 					= {0};
GPIO_Handler_t 	handlerDT 					= {0};
GPIO_Handler_t 	handlerBlinkyPin 			= {0};
GPIO_Handler_t	handlerTransistor1			= {0};
GPIO_Handler_t	handlerPinTransistor2		= {0};
GPIO_Handler_t	handlerPinDisplay_a			= {0};
GPIO_Handler_t	handlerPinDisplay_b			= {0};
GPIO_Handler_t	handlerPinDisplay_c			= {0};
GPIO_Handler_t	handlerPinDisplay_d			= {0};
GPIO_Handler_t	handlerPinDisplay_e			= {0};
GPIO_Handler_t	handlerPinDisplay_f			= {0};
GPIO_Handler_t	handlerPinDisplay_g			= {0};


/*Definición de los timers*/
BasicTimer_Handler_t handlerBlinkyTimer = {0};
BasicTimer_Handler_t handlerTimerDisplay = {0};

/* Definición del exti */
EXTI_Config_t ExtiClock = {0};
EXTI_Config_t UserExti = {0};

uint8_t encoderEdge = 0;   //Bandera
uint8_t counter = 0;

uint8_t s = 0;    //Probar el funcionamiento del encoder

/* Prototipos de funciones del main */
void init_Hardware(void);
void callback_extInt13(void);

int main(void){

	/* Inicializacion de elementos*/
	init_Hardware();

	while(1){

		if((encoderEdge ==1) && (GPIO_ReadPin(&handlerDT)==0)){
			if(counter <=0){
				counter = 0;
			}else{
				counter--;
			}
			encoderEdge = 0;
		}
		else if((encoderEdge == 1) && (GPIO_ReadPin(&handlerDT)==1)){
			if(counter>99){
				counter = 99;
			}
			else{
				counter++;
			}
			encoderEdge = 0;     //Bajar la bandera
		}

	}

	return 0;
}

void init_Hardware(void){

	/* Configuración del led de estado */
	handlerLED2.pGPIOx = GPIOA;
	handlerLED2.GPIO_PinConfig.GPIO_PinNumber 	= PIN_5;
	handlerLED2.GPIO_PinConfig.GPIO_PinMode 	= GPIO_MODE_OUT;
	handlerLED2.GPIO_PinConfig.GPIO_PinOType	= GPIO_OTYPE_PUSHPULL;
	handlerLED2.GPIO_PinConfig.GPIO_PinSpeed	= GPIO_OSPEED_FAST;
	handlerLED2.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	GPIO_Config(&handlerLED2);

	/* Configuración del TIM2 para controlar el blinky */
	handlerBlinkyTimer.ptrTIMx = TIM2;
	handlerBlinkyTimer.TIMx_Config.TIMx_mode		= BTIMER_MODE_UP;
	handlerBlinkyTimer.TIMx_Config.TIMx_speed		= BTIMER_SPEED_1ms;
	handlerBlinkyTimer.TIMx_Config.TIMx_period		= 250; // Interrupcion cada 250 ms
	handlerBlinkyTimer.TIMx_Config.TIMx_interruptEnable = BTIMER_INTERRUP_ENABLE;
	BasicTimer_Config(&handlerBlinkyTimer);

	/* Configuración del TIM5 que controla el Display */
	handlerTimerDisplay.ptrTIMx 							= TIM5;
	handlerTimerDisplay.TIMx_Config.TIMx_mode 				= BTIMER_MODE_UP;
	handlerTimerDisplay.TIMx_Config.TIMx_speed 				= BTIMER_SPEED_1ms;
	handlerTimerDisplay.TIMx_Config.TIMx_period 			= 10;                   //Periodo de 10ms
	handlerTimerDisplay.TIMx_Config.TIMx_interruptEnable	= BTIMER_INTERRUP_ENABLE;


	/* Configuración del CLK */
	handlerCLK.pGPIOx = GPIOC;
	handlerCLK.GPIO_PinConfig.GPIO_PinNumber 	      = PIN_13;
	handlerCLK.GPIO_PinConfig.GPIO_PinMode 	          = GPIO_MODE_IN;
	handlerCLK.GPIO_PinConfig.GPIO_PinOType	          = GPIO_OTYPE_PUSHPULL;
	handlerCLK.GPIO_PinConfig.GPIO_PinSpeed	          = GPIO_OSPEED_FAST;
	handlerCLK.GPIO_PinConfig.GPIO_PinPuPdControl     = GPIO_PUPDR_NOTHING;
	GPIO_Config(&handlerCLK);

	/* Configuración del DT */
	handlerDT.pGPIOx = GPIOB;
	handlerDT.GPIO_PinConfig.GPIO_PinNumber 	      = PIN_8;
	handlerDT.GPIO_PinConfig.GPIO_PinMode 	          = GPIO_MODE_IN;
	handlerDT.GPIO_PinConfig.GPIO_PinOType	          = GPIO_OTYPE_PUSHPULL;
	handlerDT.GPIO_PinConfig.GPIO_PinSpeed	          = GPIO_OSPEED_FAST;
	handlerDT.GPIO_PinConfig.GPIO_PinPuPdControl      = GPIO_PUPDR_NOTHING;
	GPIO_Config(&handlerDT);

	/* Configuración del SW */
	handlerPinExternalBotton.pGPIOx 										= GPIOA;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinNumber					= PIN_9;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinMode					= GPIO_MODE_IN;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinOType					= GPIO_OTYPE_PUSHPULL;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinSpeed					= GPIO_OSPEED_MEDIUM;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinPuPdControl				= GPIO_PUPDR_NOTHING;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinAltFunMode				= AF0;


	/* Configuración del segmento "a" del display */
	handlerPinDisplay_a.pGPIOx 												= GPIOC;
	handlerPinDisplay_a.GPIO_PinConfig.GPIO_PinNumber			 			= PIN_1;
	handlerPinDisplay_a.GPIO_PinConfig.GPIO_PinMode 						= GPIO_MODE_OUT;
	handlerPinDisplay_a.GPIO_PinConfig.GPIO_PinOType 						= GPIO_OTYPE_PUSHPULL;
	handlerPinDisplay_a.GPIO_PinConfig.GPIO_PinPuPdControl 					= GPIO_PUPDR_NOTHING;
	handlerPinDisplay_a.GPIO_PinConfig.GPIO_PinSpeed 						= GPIO_OSPEED_MEDIUM;
	handlerPinDisplay_a.GPIO_PinConfig.GPIO_PinAltFunMode					= AF0;

	/* Configuración del  segmento "b" del display */
	handlerPinDisplay_b.pGPIOx 												= GPIOC;
	handlerPinDisplay_b.GPIO_PinConfig.GPIO_PinNumber			 			= PIN_10;
	handlerPinDisplay_b.GPIO_PinConfig.GPIO_PinMode 						= GPIO_MODE_OUT;
	handlerPinDisplay_b.GPIO_PinConfig.GPIO_PinOType 						= GPIO_OTYPE_PUSHPULL;
	handlerPinDisplay_b.GPIO_PinConfig.GPIO_PinPuPdControl 					= GPIO_PUPDR_NOTHING;
	handlerPinDisplay_b.GPIO_PinConfig.GPIO_PinSpeed 						= GPIO_OSPEED_MEDIUM;
	handlerPinDisplay_b.GPIO_PinConfig.GPIO_PinAltFunMode					= AF0;

	/* Configuración del segmento "c" del display */
	handlerPinDisplay_c.pGPIOx 												= GPIOA;
	handlerPinDisplay_c.GPIO_PinConfig.GPIO_PinNumber			 			= PIN_2;
	handlerPinDisplay_c.GPIO_PinConfig.GPIO_PinMode 						= GPIO_MODE_OUT;
	handlerPinDisplay_c.GPIO_PinConfig.GPIO_PinOType 						= GPIO_OTYPE_PUSHPULL;
	handlerPinDisplay_c.GPIO_PinConfig.GPIO_PinPuPdControl 					= GPIO_PUPDR_NOTHING;
	handlerPinDisplay_c.GPIO_PinConfig.GPIO_PinSpeed 						= GPIO_OSPEED_MEDIUM;
	handlerPinDisplay_c.GPIO_PinConfig.GPIO_PinAltFunMode					= AF0;

	/* Configuración del segmento "d" del display */
	handlerPinDisplay_d.pGPIOx 												= GPIOA;
	handlerPinDisplay_d.GPIO_PinConfig.GPIO_PinNumber			 			= PIN_13;
	handlerPinDisplay_d.GPIO_PinConfig.GPIO_PinMode 						= GPIO_MODE_OUT;
	handlerPinDisplay_d.GPIO_PinConfig.GPIO_PinOType 						= GPIO_OTYPE_PUSHPULL;
	handlerPinDisplay_d.GPIO_PinConfig.GPIO_PinPuPdControl 					= GPIO_PUPDR_NOTHING;
	handlerPinDisplay_d.GPIO_PinConfig.GPIO_PinSpeed 						= GPIO_OSPEED_FAST;
	handlerPinDisplay_d.GPIO_PinConfig.GPIO_PinAltFunMode					= AF0;

	/* Configuración del segmento "e" del display */
	handlerPinDisplay_e.pGPIOx 												= GPIOA;
	handlerPinDisplay_e.GPIO_PinConfig.GPIO_PinNumber			 			= PIN_15;
	handlerPinDisplay_e.GPIO_PinConfig.GPIO_PinMode 						= GPIO_MODE_OUT;
	handlerPinDisplay_e.GPIO_PinConfig.GPIO_PinOType 						= GPIO_OTYPE_PUSHPULL;
	handlerPinDisplay_e.GPIO_PinConfig.GPIO_PinPuPdControl 					= GPIO_PUPDR_NOTHING;
	handlerPinDisplay_e.GPIO_PinConfig.GPIO_PinSpeed 						= GPIO_OSPEED_MEDIUM;
	handlerPinDisplay_e.GPIO_PinConfig.GPIO_PinAltFunMode					= AF0;

	/* Configuración del segmento "f" del display */
	handlerPinDisplay_f.pGPIOx 												= GPIOA;
	handlerPinDisplay_f.GPIO_PinConfig.GPIO_PinNumber			 			= PIN_4;
	handlerPinDisplay_f.GPIO_PinConfig.GPIO_PinMode 						= GPIO_MODE_OUT;
	handlerPinDisplay_f.GPIO_PinConfig.GPIO_PinOType 						= GPIO_OTYPE_PUSHPULL;
	handlerPinDisplay_f.GPIO_PinConfig.GPIO_PinPuPdControl 					= GPIO_PUPDR_NOTHING;
	handlerPinDisplay_f.GPIO_PinConfig.GPIO_PinSpeed 						= GPIO_OSPEED_MEDIUM;
	handlerPinDisplay_f.GPIO_PinConfig.GPIO_PinAltFunMode					= AF0;

	/* Configuración del segmento "g" del display */
	handlerPinDisplay_g.pGPIOx 												= GPIOB;
	handlerPinDisplay_g.GPIO_PinConfig.GPIO_PinNumber			 			= PIN_3;
	handlerPinDisplay_g.GPIO_PinConfig.GPIO_PinMode 						= GPIO_MODE_OUT;
	handlerPinDisplay_g.GPIO_PinConfig.GPIO_PinOType 						= GPIO_OTYPE_PUSHPULL;
	handlerPinDisplay_g.GPIO_PinConfig.GPIO_PinPuPdControl 					= GPIO_PUPDR_NOTHING;
	handlerPinDisplay_g.GPIO_PinConfig.GPIO_PinSpeed 						= GPIO_OSPEED_MEDIUM;
	handlerPinDisplay_g.GPIO_PinConfig.GPIO_PinAltFunMode					= AF0;

	//Configuración del pin sobre el cual funciona el transistor left que controla el display izquierdo;   LISTO
	handlerPinDisplay_TLeft.pGPIOx 													= GPIOC;
	handlerPinDisplay_TLeft.GPIO_PinConfig.GPIO_PinNumber			 				= PIN_13;
	handlerPinDisplay_TLeft.GPIO_PinConfig.GPIO_PinMode 							= GPIO_MODE_OUT;
	handlerPinDisplay_TLeft.GPIO_PinConfig.GPIO_PinOType 							= GPIO_OTYPE_PUSHPULL;
	handlerPinDisplay_TLeft.GPIO_PinConfig.GPIO_PinPuPdControl 						= GPIO_PUPDR_NOTHING;
	handlerPinDisplay_TLeft.GPIO_PinConfig.GPIO_PinSpeed 							= GPIO_OSPEED_MEDIUM;
	handlerPinDisplay_TLeft.GPIO_PinConfig.GPIO_PinAltFunMode						= AF0;

	//Configuración del pin sobre el cual funciona el transistor right que controla el display derecho;   LISTO
	handlerPinDisplay_TRight.pGPIOx 												= GPIOC;
	handlerPinDisplay_TRight.GPIO_PinConfig.GPIO_PinNumber			 				= PIN_15;
	handlerPinDisplay_TRight.GPIO_PinConfig.GPIO_PinMode 							= GPIO_MODE_OUT;
	handlerPinDisplay_TRight.GPIO_PinConfig.GPIO_PinOType 							= GPIO_OTYPE_PUSHPULL;
	handlerPinDisplay_TRight.GPIO_PinConfig.GPIO_PinPuPdControl 					= GPIO_PUPDR_NOTHING;
	handlerPinDisplay_TRight.GPIO_PinConfig.GPIO_PinSpeed 							= GPIO_OSPEED_MEDIUM;
	handlerPinDisplay_TRight.GPIO_PinConfig.GPIO_PinAltFunMode						= AF0;



	//Configuracion del pin sobre el cual se recibirá la señal del botón (sw)        LISTO
	handlerPinExternalBotton.pGPIOx 																= GPIOA;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinNumber											= PIN_9;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinMode											= GPIO_MODE_IN;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinOType											= GPIO_OTYPE_PUSHPULL;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinSpeed											= GPIO_OSPEED_MEDIUM;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinPuPdControl										= GPIO_PUPDR_NOTHING;
	handlerPinExternalBotton.GPIO_PinConfig.GPIO_PinAltFunMode										= AF0;


	//Configuración del handlerTimerDisplay correspondiente al Timer5 que controla el Display
	handlerTimerDisplay.ptrTIMx 													= TIM5;
	handlerTimerDisplay.TIMx_Config.TIMx_mode 										= BTIMER_MODE_UP;
	handlerTimerDisplay.TIMx_Config.TIMx_speed 										= BTIMER_SPEED_1ms;
	handlerTimerDisplay.TIMx_Config.TIMx_period 									= 10;                   //Periodo de 10ms
	handlerTimerDisplay.TIMx_Config.TIMx_interruptEnable							= BTIMER_INTERRUP_ENABLE;



	//Cargamos la configuración del EXTI
	ExtiClock.pGPIOHandler = &handlerCLK;
	ExtiClock.edgeType = EXTERNAL_INTERRUPT_FALLING_EDGE;
	extInt_Config(&ExtiClock);


}

void BasicTimer2_Callback(void){
	GPIOxTooglePin(&handlerLED2);
}

void callback_extInt13(void){
	encoderEdge = 1;    //Subiendo la bandera
	s++;
}



